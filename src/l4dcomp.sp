/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdktools>
//iAddonbits flags
#define FL_FIRST_AID_KIT (1<<0)
#define FL_PAIN_PILLS (1<<1)
#define FL_PIPE_BOMB (1<<2)
#define FL_MOLOTOV (1<<3)
#define FL_PRIMARY_PISTOL (1<<4)  //For some reason the primary bit seems to move when you get double pistols
#define FL_PRIMARY (1<<5)
#define FL_PISTOL_PRIMARY (1<<6) //Is 1 when you have a primary weapon and dual pistols
#define FL_PISTOL (1<<7) //Is 1 when you have dual pistols
#define COMP_DEBUG 1

public Plugin:myinfo = 
{
	name = "L4D Competitive Plugin Rotoblin Edition",
	author = "Frustian, D4rKr0W",
	description = "Adds various improvements for competitive L4D",
	version = "1.3.2.rotoblin",
	url = "https://code.google.com/p/rotoblin"
}
//cvar handles
new Handle:CPenabled;
new Handle:FKenabled;
new Handle:TDenabled;
new Handle:TFenabled;
new Handle:FKFenabled;
new Handle:TCenabled;
new Handle:DPenabled;
new Handle:PAenabled;
new Handle:TDFenabled;
//Various global variables
new ConvertedPill[64]; //Stores entity IDs of pills converted by the mod
new PillsPickedUp; //Stores how many converted pills the survivors picked up
//new TierTwoConverted; //Stores whether the tier 2 that spawns after round start have been removed
new TierTwoConverted2; //Stores whether the tier 2 that spawns after round start have been removed
new Handle:AITankThaw; //Used to disable freezing the AI tank if it passed to a player
new Float:TierTwoLocations[10][2][2][3]; //Stores the loctions of tier 2 weapons for the second round I do not consider hunting rifle neccessary to be removed. First index is the spawn number, second is whether it is pump(0) or uzi(1), third is origin(0) or rotation(1), last index are the 3 vecter co-ordinates.
new TierTwoEntID[10][2]; //Stores tier 2 ent IDs
new TierTwoSpawned = 1; //Effectively 1 if it is the first round, 0 if the second round.
new TierTwoSpawned2 = 1; //Effectively 1 if it is the first round, 0 if the second round.
new TankCulled; //Records whether the last tank spawn was culled.
new Float:SurvivorHealthTime[4]; //Records the survivor's temp health
new Float:SurvivorHealthBuffer[4]; //Records the survivor's temp health
new TankFrustration = -1; //Records the tank's frustration
new InPause; //Records whether the game is paused
new SurPause; //Records whether the survivors have requested a pause
new InfPause; //Records whether the infected have requested a pause
new PauseClientIndex[MAXPLAYERS+1]; //Records client IDs as they were when the game was paused
new Float:InfectedDeathTime[MAXPLAYERS+1]; //Records how much time left people in death mode when the game was paused
new String:InfectedAuthIDIndex[MAXPLAYERS+1][33]; //Stores steam IDs of frozen infected.
new BuggedT2Removed; //Records if bugged tier 2 was removed this map
new PillSpawnGiven[4]; //Records the pill spawner IDs that have been used
new String:SurvivorWeapons[4][5][32];
new SurvivorAmmo[4][7]; //0-3: Primary Ammo Reserve (HR,AR,SMG,SG) 4:IsDualPistols 5:Primary clip 6:Pistol clip
new unpausing;
new adminpause;
public OnPluginStart()
{
	CreateConVar("l4d_comp_version", "1.3.2", "Comp Plugin Version",FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_NOTIFY);
	CPenabled = CreateConVar("l4d_comp_enable", "0", "Enable Comp Plugin",FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_NOTIFY);
	FKenabled = CreateConVar("l4d_kit_disable", "1", "Enable First Aid Kit Disable",FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_NOTIFY);
	FKFenabled = CreateConVar("l4d_finale_kit_enable", "1", "Spawn 4 first aid kits on finale",FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_NOTIFY);
	TDFenabled = CreateConVar("l4d_finale_tier2_enable", "0", "Spawn Tier 2 in finales.  0:No tier 2, 1:All tier 2 spawns, 2:Jerkstore mode, only one AS, and one AR, 3:one AS&AR in the saferoom, another pair at finale button",FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_NOTIFY);
	TDenabled = CreateConVar("l4d_tier2_disable", "1", "Enable Tier 2 Disable",FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_NOTIFY);
	TFenabled = CreateConVar("l4d_tankfix", "1", "Enable Tank Fix",FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_NOTIFY);
	DPenabled = CreateConVar("l4d_dupepillfix", "1", "Enable Duplicate Pill Fix",FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_NOTIFY);
	TCenabled = CreateConVar("l4d_tankcontrolfix", "1", "Enable Tank Control Meter Fix",FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_NOTIFY);
	PAenabled = CreateConVar("l4d_pauseenabled", "1", "Enable Pausing",FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_NOTIFY);
	HookEvent("round_end", Event_RoundEnd, EventHookMode_PostNoCopy);
	HookEvent("round_start", Event_RoundStart, EventHookMode_PostNoCopy);
	HookEvent("spawner_give_item", Event_SpawnGive, EventHookMode_Post);
	HookEvent("tank_spawn", Event_TankSpawn, EventHookMode_Post);
	HookEvent("player_hurt", Event_PlayerHurt, EventHookMode_Post);
	//HookEvent("player_first_spawn", Event_PlayerSpawn, EventHookMode_PostNoCopy);
	HookEvent("player_incapacitated_start", Event_BeforeIncap, EventHookMode_Post);
	HookEvent("tank_frustrated", Event_Culled, EventHookMode_PostNoCopy);
	RegConsoleCmd("sm_fpause", RequestPause);
	RegConsoleCmd("sm_funpause", RequestUnpause);
	RegAdminCmd("sm_forcepause", ForcePause, ADMFLAG_BAN);
}
public DropSlot(client, slot)
{
	if (GetPlayerWeaponSlot(client, slot) > 0)
	{
		SetCommandFlags("give", GetCommandFlags("give") & ~FCVAR_CHEAT);
		new String:sWeapon[32];
		GetEdictClassname(GetPlayerWeaponSlot(client, slot), sWeapon, 32);
		if (slot == 1)
			FakeClientCommand(client, "give pistol");
		FakeClientCommand(client, "give %s", sWeapon);
		//RemovePlayerItem(client, GetPlayerWeaponSlot(client, slot));
		SetCommandFlags("give", GetCommandFlags("give") | FCVAR_CHEAT);
		new dropcount;
		new ent = -1;
		new prev = 0;
		while ((ent = FindEntityByClassname(ent, sWeapon)) != -1)
		{
			if (prev)
			{
					new Float:location[3];
					new Float:cllocation[3];
					GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
					GetEntPropVector(client, Prop_Send, "m_vecOrigin", cllocation);
					if (GetVectorDistance(location, cllocation) < 100)
						if (dropcount > 5)
							RemoveEdict(prev);
						else
							dropcount++;
			}
			prev = ent;
		}
		if (prev)
		{
				new Float:location[3];
				new Float:cllocation[3];
				GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
				GetEntPropVector(client, Prop_Send, "m_vecOrigin", cllocation);
				if (GetVectorDistance(location, cllocation) < 100)
					if (dropcount > 5)
						RemoveEdict(prev);
					else
						dropcount++;
		}
	}
}
public Action:HintText(Handle:Timer, any:TankClient) //This displays a fake tank control meter if the tank lost the original one
{
	if (GetEntProp(TankClient, Prop_Send, "m_zombieClass") != 5 || GetClientTeam(TankClient) != 3 || !IsPlayerAlive(TankClient) || GetEntProp(TankClient, Prop_Data, "m_fFlags") & FL_ONFIRE)
		return Plugin_Stop;
	if (!InPause)
		PrintHintText(TankClient, "Tank Control: %d", 100-GetEntProp(TankClient, Prop_Send, "m_frustration"));
	return Plugin_Continue;
}
public Action:ResetAllTemp(Handle:Timer) //This tries to maintain the game state as it was when the game was paused
{
	if (!InPause)
		return Plugin_Stop;
	for (new i=1;i<=MaxClients;i++)
	{
		if (IsClientInGame(i) && IsPlayerAlive(i) && GetClientTeam(i) == 2)
		{
			ResetTempHealth(i);
			//if (GetEntProp(i, Prop_Send, "m_hActiveWeapon") != GetPlayerWeaponSlot(i, 3))
			//EquipPlayerWeapon(i, GetPlayerWeaponSlot(i, 3));
			SetEntProp(i, Prop_Send, "m_reviveOwner", 0);
			SetEntProp(i, Prop_Send, "m_reviveTarget", 0);
			SetEntProp(i, Prop_Send, "m_healOwner", 0);
			SetEntProp(i, Prop_Send, "m_healTarget", 0);
			for (new j=4;j>=0;j--)
				if (GetPlayerWeaponSlot(i, j) > 0)
				{
					DropSlot(i, j);
					RemovePlayerItem(i, GetPlayerWeaponSlot(i, j));
				}
		}
		else if (IsClientInGame(i) && IsPlayerAlive(i) && GetClientTeam(i) == 3)
		{
			if (GetEntProp(i, Prop_Send, "m_zombieClass") == 5 && TankFrustration != -1)
			{
				SetEntProp(i, Prop_Send, "m_frustration", TankFrustration)
			}
			if (GetEntityMoveType(i) != MOVETYPE_NONE && GetEntityMoveType(i) != MOVETYPE_NOCLIP)
				SetEntityMoveType(i, MOVETYPE_NONE);
		}
	}
	if (!unpausing)
		PrintHintTextToAll("The game has been paused.\nType !funpause in chat to unpause.");
	return Plugin_Continue;
}
public Action:ResetIncap(Handle:timer, Handle:pack)  //Gets a survivor up if they are incapped during a pause, if the plugin works fine this should never be called, but is there as a backup.
{
	ResetPack(pack);
	new client = ReadPackCell(pack);
	new health = ReadPackCell(pack);
	if (IsClientInGame(client) && IsPlayerAlive(client))
	{
		SetEntProp(client, Prop_Send, "m_isIncapacitated", 0)
		SetEntityHealth(client, health);
	}
}
public Action:RemoveTierTwoTimer(Handle:Timer)
{
	decl String:map[128];
	GetCurrentMap(map, sizeof(map));
	static timesLooped = 1;
	if (timesLooped == 1)
	{
		for (new i=0;i<10;i++)
			for (new j=0;j<2;j++)
				TierTwoEntID[i][j] = 0;
		if (TierTwoSpawned || StrContains(map, "_garage0") != -1)
		{
			RemoveTierTwo(0);
			TierTwoSpawned = 0;
		}
		else if (!TierTwoSpawned)
		{
			SpawnTierOne();
		}
		timesLooped++;
		return Plugin_Continue;
	}
	if (BuggedT2Removed || timesLooped > 30)
	{
		TierTwoSpawned2 = 0;
		timesLooped = 1;
		ClearKits();
		return Plugin_Stop;
	}
	if (TierTwoSpawned2 || StrContains(map, "_garage0") != -1)
	{
		RemoveTierTwo(1);
		//TierTwoSpawned = 0;
	}
	//if (!TierTwoSpawned2)
	//{
		//SpawnTierOne();
	//}
	timesLooped++;
	return Plugin_Continue;
}
public Action:FreezeSI(Handle:Timer, Handle:pack) //This freezes a SI to simulate a spawn time
{
	ResetPack(pack);
	new client = ReadPackCell(pack);
	new targettime = ReadPackCell(pack);
	new timeslooped = RoundToCeil(GetGameTime())-ReadPackCell(pack);
	if (targettime <= timeslooped || GetEntProp(client, Prop_Send, "m_zombieClass") == 5)  //Will automatically deactivate if the frozen player gets control of a tank
	{
		SetEntityMoveType(client, MOVETYPE_CUSTOM);
		PrintHintText(client, "You are free to move.");
		return Plugin_Stop;
	}
	if (GetEntityMoveType(client) != MOVETYPE_NONE && GetEntityMoveType(client) != MOVETYPE_NOCLIP)
		SetEntityMoveType(client, MOVETYPE_NONE);
	PrintHintText(client, "You are frozen for %d seconds.\nThis is to simulate your remaining spawn time during the pause.", targettime-timeslooped);
	return Plugin_Continue;
}
public Action:RequestPause(client, args)  //Player requested a pause
{
	if (!GetConVarInt(CPenabled)||!GetConVarInt(PAenabled))
		return Plugin_Handled;
	decl String:map[128];
	GetCurrentMap(map, sizeof(map));
	if (GetClientTeam(client) == 2)
	{
		if (!GetConVarInt(FindConVar("director_ready_duration")) && !InPause)
			ReplyToCommand(client, "[SM] The game has not started yet!");
		else if (!IsSafeToPause())
			ReplyToCommand(client, "[SM] One of the survivors is too close to the crescendo to pause!");
		else if (IsFinale())
			ReplyToCommand(client, "[SM] You can not pause on the finale!");
		else if (InfPause && !InPause)
		{
			PauseGame();
			PrintToChatAll("[SM] The Survivors have agreed to pause the game.");
			PrintToChatAll("[SM] The game is now paused. Use !funpause to unpause.");
			InfPause = 0;
			SurPause = 0;
		}
		else if (!SurPause && !InfPause && !InPause)
		{
			PrintToChatAll("[SM] The Survivors have requested a pause.  The Infected must agree by typing !fpause");
			SurPause = 1;
		}
		else if (SurPause)
			ReplyToCommand(client, "[SM] Your team has already requested a pause!");
		else if (InPause)
			ReplyToCommand(client, "[SM] The game is already paused! use !funpause to unpause the game.");
	}
	else if (GetClientTeam(client) == 3)
	{
		if (!GetConVarInt(FindConVar("director_ready_duration")) && !InPause)
			ReplyToCommand(client, "[SM] The game has not started yet!");
		else if (!IsSafeToPause())
			ReplyToCommand(client, "[SM] One of the survivors is too close to the crescendo to pause!");
		else if (IsFinale())
			ReplyToCommand(client, "[SM] You can not pause on the finale!");
		else if (SurPause && !InPause)
		{
			PauseGame();
			PrintToChatAll("[SM] The Infected have agreed to pause the game.");
			PrintToChatAll("[SM] The game is now paused. Use !funpause to unpause.");
			InfPause = 0;
			SurPause = 0;
		}
		else if (!SurPause && !InfPause && !InPause)
		{
			PrintToChatAll("[SM] The Infected have requested a pause.  The Survivors must agree by typing !fpause");
			InfPause = 1;
		}
		else if (InfPause)
			ReplyToCommand(client, "[SM] Your team has already requested a pause!");
		else if (InPause)
			ReplyToCommand(client, "[SM] The game is already paused! Use !funpause to unpause the game.");
	}
	else
		ReplyToCommand(client, "[SM] You are not on a valid team!");
	return Plugin_Handled;
}
public Action:ForcePause(client, args) //Admin forced a pause
{
	if (!GetConVarInt(CPenabled)||!GetConVarInt(PAenabled))
		return Plugin_Handled;
	if (!InPause)
	{
		PrintToChatAll("[SM] An admin has forced the game to pause.");
		PauseGame();
		adminpause = 1;
	}
	else
	{
		PrintToChatAll("[SM] An admin has forced the game to unpause.");
		new Handle:pack;
		CreateDataTimer(1.0, UnPauseCountDown, pack, TIMER_REPEAT);
		WritePackCell(pack, RoundToCeil(GetGameTime()));
		PrintHintTextToAll("Unpausing in 5...");
		adminpause = 0;
	}
	return Plugin_Handled;
}
public Action:RequestUnpause(client, args) //Player requested an unpause
{
	if (!GetConVarInt(CPenabled)||!GetConVarInt(PAenabled))
		return Plugin_Handled;
	if (adminpause && ~GetUserFlagBits(client) & ADMFLAG_BAN)
	{
		ReplyToCommand(client, "[SM] An admin must unpause a forced pause!");
		return Plugin_Handled;
	}
	if (InPause && !unpausing)
	{
		if (GetClientTeam(client) == 2)
		{
			new Handle:pack;
			CreateDataTimer(1.0, UnPauseCountDown, pack, TIMER_REPEAT);
			WritePackCell(pack, RoundToCeil(GetGameTime()));
			PrintHintTextToAll("Unpausing in 5...");
			PrintToChatAll("[SM] The Survivors have unpaused the game.");
		}
		else if (GetClientTeam(client) == 3)
		{
			new Handle:pack;
			CreateDataTimer(1.0, UnPauseCountDown, pack, TIMER_REPEAT);
			WritePackCell(pack, RoundToCeil(GetGameTime()));
			PrintHintTextToAll("Unpausing in 5...");
			PrintToChatAll("[SM] The Infected have unpaused the game.");
		}
		else
			ReplyToCommand(client, "[SM] You are not on a valid team!");
	}
	else
	{
		if (GetClientTeam(client) == 2 && SurPause)
		{
			SurPause = 0;
			PrintToChatAll("[SM] The Survivors have cancelled their pause request.");
		}
		else if (GetClientTeam(client) == 3 && InfPause)
		{
			InfPause = 0;
			PrintToChatAll("[SM] The Infected have cancelled their pause request.");
		}
		else
			ReplyToCommand(client, "[SM] The game is not paused! Use !fpause to request a pause.");
	}
	return Plugin_Handled;
}
public OnMapStart()
{
	if (!GetConVarInt(CPenabled))
		return;
	if (GetConVarInt(FKenabled))
		PillsPickedUp = 0;
	if (GetConVarInt(FKenabled))
	{
		SetConVarFloat(FindConVar("director_vs_convert_pills"), 0.0);  //If you are disabling medkits in safe room, I assume you want all of them gone. Besides, this cvar would convert safe room pills I converted into medkits.
		SetConVarFloat(FindConVar("director_convert_pills"), 0.0);
	}
	if (GetConVarInt(TDenabled))
	{
		for (new i=0;i<10;i++)
			for (new j=0;j<2;j++)
				for (new k=0;k<2;k++)
					for (new l=0;l<3;l++)
						TierTwoLocations[i][j][k][l] = 0.0;
		for (new i=0;i<10;i++)
			for (new j=0;j<2;j++)
				TierTwoEntID[i][j] = 0;
		TierTwoSpawned = 1;
		TierTwoSpawned2 = 1;
	}
	for (new i=0;i<4;i++)
		for (new j=0;j<5;j++)
			Format(SurvivorWeapons[i][j], 32, "");
}
public OnMapEnd()
{
	if (GetConVarInt(CPenabled) && GetConVarInt(TDenabled))
	{
		for (new i=0;i<10;i++)
			for (new j=0;j<2;j++)
				for (new k=0;k<2;k++)
					for (new l=0;l<3;l++)
						TierTwoLocations[i][j][k][l] = 0.0;
		for (new i=0;i<10;i++)
			for (new j=0;j<2;j++)
				TierTwoEntID[i][j] = 0;
		TierTwoSpawned = 1;
		TierTwoSpawned2 = 1;
	}
	if (InPause)
		ResumeGame();
	SurPause = 0;
	InfPause = 0;
	BuggedT2Removed = 0;
	adminpause = 0;
	unpausing = 0;
	for (new i=0;i<3;i++)
		PillSpawnGiven[i] = 0;
}
public Action:Event_PlayerHurt(Handle:event, const String:name[], bool:dontBroadcast) //Used to give any health lost back during the pause.
{
	if (InPause && GetConVarInt(CPenabled))
		SetEntityHealth(GetClientOfUserId(GetEventInt(event, "userid")), GetEventInt(event, "health") + GetEventInt(event, "dmg_health"));
}
public Action:Event_BeforeIncap(Handle:event, const String:name[], bool:dontBroadcast) //Used to detect if a player was incapped during a pause, since all survivors should have godmode this should never be activated, but is here as a backup.
{
	if (InPause && GetConVarInt(CPenabled))
	{
		new Handle:pack;
		CreateDataTimer(0.1, ResetIncap, pack);
		WritePackCell(pack, GetClientOfUserId(GetEventInt(event, "userid")));
		WritePackCell(pack, GetClientHealth(GetClientOfUserId(GetEventInt(event, "userid"))));
	}
}
public Action:Event_RoundEnd(Handle:event, const String:name[], bool:dontBroadcast)
{
	if (!GetConVarInt(CPenabled))
		return;
	//TierTwoConverted = 0;
	TierTwoConverted2 = 0;
	PillsPickedUp = 0;
	if (InPause)
		ResumeGame();
	SurPause = 0;
	InfPause = 0;
	for (new i=0;i<3;i++)
		PillSpawnGiven[i] = 0;
	for (new i=0;i<10;i++)
		for (new j=0;j<2;j++)
			TierTwoEntID[i][j] = 0;
}
public Action:Event_RoundStart(Handle:event, const String:name[], bool:dontBroadcast)
{
	if (!GetConVarInt(CPenabled))
		return;
	PillsPickedUp = 0;
	if (InPause)
		ResumeGame();
	if (GetConVarInt(FKenabled)) //Changes all medkits on the map into pills, and stores the converted pill's entity ID to be able to convert them into medkits later if needed
	{
		new String:Painpill_model[128] = "w_models/weapons/w_eq_painpills.mdl";
		if (!IsModelPrecached(Painpill_model))
		{
			PrecacheModel(Painpill_model);
		}
		new Float:playerstart[3];
		new player = FindEntityByClassname(-1, "prop_door_rotating_checkpoint");
		GetEntPropVector(player, Prop_Send, "m_vecOrigin", playerstart);	
		new ent = -1;
		new prev = 0;
		new i = 0;
		decl String:map[128];
		GetCurrentMap(map, 128);
		while ((ent = FindEntityByClassname(ent, "weapon_first_aid_kit_spawn")) != -1)
		{
			new index = CreateEntityByName("weapon_pain_pills_spawn");
			if (index)
			{
				if (prev)
				{
					new Float:location[3];
					new Float:angle[3];
					GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
					GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
					if (GetVectorDistance(location, playerstart) < 500 || !IsFinale() || !GetConVarInt(FKFenabled))
					{
						RemoveEdict(prev);
						SetEntityModel(index, Painpill_model);
						TeleportEntity(index, location, angle, NULL_VECTOR);
						DispatchSpawn(index);
						ConvertedPill[i] = index;
						i++;
					}
				}
				prev = ent;
			}
		}
		new index = CreateEntityByName("weapon_pain_pills_spawn");
		if (index)
		{
			if (prev)
			{
				new Float:location[3];
				new Float:angle[3];
				GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
				GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
				if (GetVectorDistance(location, playerstart) < 500 || !IsFinale())
				{
					RemoveEdict(prev);
					SetEntityModel(index, Painpill_model);
					TeleportEntity(index, location, angle, NULL_VECTOR);
					DispatchSpawn(index);
					ConvertedPill[i] = index;
				}
			}
		}
	}
	if (GetConVarInt(TDenabled))
	{
		for (new i=0;i<10;i++)
			for (new j=0;j<2;j++)
				TierTwoEntID[i][j] = 0;
		//TierTwoConverted = 0;
		TierTwoConverted2 = 0;
		CreateTimer(0.1, RemoveTierTwoTimer, _, TIMER_REPEAT);
	}
}

public RemoveTierTwo(IsSecond) //Removes tier 2, spawns tier one in the same location, and stores the locations
{
	decl String:map[128];
	GetCurrentMap(map, sizeof(map));
	new tierDisable = GetConVarInt(TDFenabled);
	if (IsFinale() && tierDisable)
	{
		switch(tierDisable)
		{
			case 2:
			{
				if (IsSecond < 2)
				{
					new String:AutoShotgun_model[128] = "models/w_models/weapons/w_autoshot_m4super.mdl";
					if (!IsModelPrecached(AutoShotgun_model))
					{
						PrecacheModel(AutoShotgun_model);
					}
					new String:Rifle_model[128] = "models/w_models/weapons/w_rifle_m16a2.mdl";
					if (!IsModelPrecached(Rifle_model))
					{
						PrecacheModel(Rifle_model);
					}
					new ent = -1;
					new prev = 0;
					new String:count[2] = "1";
					new i = 0;
					while ((ent = FindEntityByClassname(ent, "weapon_autoshotgun_spawn")) != -1)
					{
						if (prev)
						{
							new abort;
							for (new j=0;j<10;j++)
								if (prev == TierTwoEntID[j][0])
									abort = 1;
							if (!abort)
							{
								new Float:location[3];
								new Float:angle[3];
								GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
								GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
								TierTwoLocations[i][0][0] = location;
								TierTwoLocations[i][0][1] = angle;
								SetEntProp(prev, Prop_Data, "m_itemCount", 0);
								location[2] += 20;
								TeleportEntity(prev, location, angle, NULL_VECTOR);
								location[2] -= 20;
								RemoveEdict(prev);
								new index = CreateEntityByName("weapon_autoshotgun_spawn");
								TeleportEntity(index, location, angle, NULL_VECTOR);
								DispatchKeyValue(index, "count", count);
								SetEntityModel(index, AutoShotgun_model);
								DispatchSpawn(index);
								ActivateEntity(index);
								TierTwoEntID[i][0] = index;
								i++;
							}
						}
						prev = ent;
					}
					if (prev)
					{
						new abort;
						for (new j=0;j<10;j++)
							if (prev == TierTwoEntID[j][0])
								abort = 1;
						if (!abort)
						{
							new Float:location[3];
							new Float:angle[3];
							GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
							GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
							TierTwoLocations[i][0][0] = location;
							TierTwoLocations[i][0][1] = angle;
							SetEntProp(prev, Prop_Data, "m_itemCount", 0);
							location[2] += 20;
							TeleportEntity(prev, location, angle, NULL_VECTOR);
							location[2] -= 20;
							RemoveEdict(prev);
							new index = CreateEntityByName("weapon_autoshotgun_spawn");
							TeleportEntity(index, location, angle, NULL_VECTOR);
							DispatchKeyValue(index, "count", count);
							SetEntityModel(index, AutoShotgun_model);
							DispatchSpawn(index);
							ActivateEntity(index);
							TierTwoEntID[i][0] = index;
							if (IsSecond == 1)
								BuggedT2Removed = 1;
						}
					}
					ent= -1;
					prev = 0;
					i = 0;
					while ((ent = FindEntityByClassname(ent, "weapon_rifle_spawn")) != -1)
					{
						if (prev)
						{
							new abort;
							for (new j=0;j<10;j++)
								if (prev == TierTwoEntID[j][1])
									abort = 1;
							if (!abort)
							{
								new Float:location[3];
								new Float:angle[3];
								GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
								GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
								TierTwoLocations[i][1][0] = location;
								TierTwoLocations[i][1][1] = angle;
								SetEntProp(prev, Prop_Data, "m_itemCount", 0);
								location[2] += 20;
								TeleportEntity(prev, location, angle, NULL_VECTOR);
								location[2] -= 20;
								RemoveEdict(prev);
								new index = CreateEntityByName("weapon_rifle_spawn");
								TeleportEntity(index, location, angle, NULL_VECTOR);
								DispatchKeyValue(index, "count", count);
								SetEntityModel(index, Rifle_model);
								DispatchSpawn(index);
								ActivateEntity(index);
								TierTwoEntID[i][1] = index;
								i++;
							}
						}
						prev = ent;
					}
					if (prev)
					{
						new abort;
						for (new j=0;j<10;j++)
							if (prev == TierTwoEntID[j][1])
								abort = 1;
						if (!abort)
						{
							new Float:location[3];
							new Float:angle[3];
							GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
							GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
							TierTwoLocations[i][1][0] = location;
							TierTwoLocations[i][1][1] = angle;
							SetEntProp(prev, Prop_Data, "m_itemCount", 0);
							location[2] += 20;
							TeleportEntity(prev, location, angle, NULL_VECTOR);
							location[2] -= 20;
							RemoveEdict(prev);
							new index = CreateEntityByName("weapon_rifle_spawn");
							TeleportEntity(index, location, angle, NULL_VECTOR);
							DispatchKeyValue(index, "count", count);
							SetEntityModel(index, Rifle_model);
							DispatchSpawn(index);
							ActivateEntity(index);
							TierTwoEntID[i][1] = index;
							if (IsSecond == 1)
								BuggedT2Removed = 1;
						}
					}
				}
				else
				{
					new String:PumpShotgun_model[128] = "models/w_models/weapons/w_shotgun.mdl";
					if (!IsModelPrecached(PumpShotgun_model))
					{
						PrecacheModel(PumpShotgun_model);
					}
					new String:SMG_model[128] = "models/w_models/weapons/w_smg_uzi.mdl";
					if (!IsModelPrecached(SMG_model))
					{
						PrecacheModel(SMG_model);
					}
					new String:count[2] = "5";
					if (IsSecond == 2)
					{
						for (new j=0;j<10;j++)
							if(IsValidEntity(TierTwoEntID[j][0]))
							{
								new String:classname[128]
								GetEdictClassname(TierTwoEntID[j][0], classname, 128)
								if (StrEqual("weapon_autoshotgun_spawn", classname))
								{
									new Float:location[3];
									new Float:angle[3];
									GetEntPropVector(TierTwoEntID[j][0], Prop_Send, "m_vecOrigin", location);
									GetEntPropVector(TierTwoEntID[j][0], Prop_Send, "m_angRotation", angle);
									SetEntProp(TierTwoEntID[j][0], Prop_Data, "m_itemCount", 0);
									location[2] += 20;
									TeleportEntity(TierTwoEntID[j][0], location, angle, NULL_VECTOR);
									location[2] -= 20;
									RemoveEdict(TierTwoEntID[j][0]);
									new index = CreateEntityByName("weapon_pumpshotgun_spawn");
									TeleportEntity(index, location, angle, NULL_VECTOR);
									DispatchKeyValue(index, "count", count);
									SetEntityModel(index, PumpShotgun_model);
									DispatchSpawn(index);
									ActivateEntity(index);
								}
							}
					}
					else if (IsSecond == 3)
					{
						for (new j=0;j<10;j++)
							if(IsValidEntity(TierTwoEntID[j][1]))
							{
								new String:classname[128]
								GetEdictClassname(TierTwoEntID[j][1], classname, 128)
								if (StrEqual("weapon_rifle_spawn", classname))
								{
									new Float:location[3];
									new Float:angle[3];
									GetEntPropVector(TierTwoEntID[j][1], Prop_Send, "m_vecOrigin", location);
									GetEntPropVector(TierTwoEntID[j][1], Prop_Send, "m_angRotation", angle);
									SetEntProp(TierTwoEntID[j][1], Prop_Data, "m_itemCount", 0);
									location[2] += 20;
									TeleportEntity(TierTwoEntID[j][1], location, angle, NULL_VECTOR);
									location[2] -= 20;
									RemoveEdict(TierTwoEntID[j][1]);
									new index = CreateEntityByName("weapon_smg_spawn");
									TeleportEntity(index, location, angle, NULL_VECTOR);
									DispatchKeyValue(index, "count", count);
									SetEntityModel(index, SMG_model);
									DispatchSpawn(index);
									ActivateEntity(index);
								}
							}
					}
				}
			}
			case 3:
			{
				new String:AutoShotgun_model[128] = "models/w_models/weapons/w_autoshot_m4super.mdl";
				if (!IsModelPrecached(AutoShotgun_model))
				{
					PrecacheModel(AutoShotgun_model);
				}
				new String:Rifle_model[128] = "models/w_models/weapons/w_rifle_m16a2.mdl";
				if (!IsModelPrecached(Rifle_model))
				{
					PrecacheModel(Rifle_model);
				}
				new ent = -1;
				new prev = 0;
				new String:count[2] = "1";
				new i = 0;
				while ((ent = FindEntityByClassname(ent, "weapon_autoshotgun_spawn")) != -1)
				{
					if (prev)
					{
						new abort;
						for (new j=0;j<10;j++)
							if (prev == TierTwoEntID[j][0])
								abort = 1;
						if (!abort)
						{
							new Float:location[3];
							new Float:angle[3];
							GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
							GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
							TierTwoLocations[i][0][0] = location;
							TierTwoLocations[i][0][1] = angle;
							SetEntProp(prev, Prop_Data, "m_itemCount", 0);
							location[2] += 20;
							TeleportEntity(prev, location, angle, NULL_VECTOR);
							location[2] -= 20;
							RemoveEdict(prev);
							new index = CreateEntityByName("weapon_autoshotgun_spawn");
							TeleportEntity(index, location, angle, NULL_VECTOR);
							DispatchKeyValue(index, "count", count);
							SetEntityModel(index, AutoShotgun_model);
							DispatchSpawn(index);
							ActivateEntity(index);
							TierTwoEntID[i][0] = index;
							i++;
						}
					}
					prev = ent;
				}
				if (prev)
				{
					new abort;
					for (new j=0;j<10;j++)
						if (prev == TierTwoEntID[j][0])
							abort = 1;
					if (!abort)
					{
						new Float:location[3];
						new Float:angle[3];
						GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
						GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
						TierTwoLocations[i][0][0] = location;
						TierTwoLocations[i][0][1] = angle;
						SetEntProp(prev, Prop_Data, "m_itemCount", 0);
						location[2] += 20;
						TeleportEntity(prev, location, angle, NULL_VECTOR);
						location[2] -= 20;
						RemoveEdict(prev);
						new index = CreateEntityByName("weapon_autoshotgun_spawn");
						TeleportEntity(index, location, angle, NULL_VECTOR);
						DispatchKeyValue(index, "count", count);
						SetEntityModel(index, AutoShotgun_model);
						DispatchSpawn(index);
						ActivateEntity(index);
						TierTwoEntID[i][0] = index;
						if (IsSecond == 1)
							BuggedT2Removed = 1;
					}
				}
				ent= -1;
				prev = 0;
				i = 0;
				while ((ent = FindEntityByClassname(ent, "weapon_rifle_spawn")) != -1)
				{
					if (prev)
					{
						new abort;
						for (new j=0;j<10;j++)
							if (prev == TierTwoEntID[j][1])
								abort = 1;
						if (!abort)
						{
							new Float:location[3];
							new Float:angle[3];
							GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
							GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
							TierTwoLocations[i][1][0] = location;
							TierTwoLocations[i][1][1] = angle;
							SetEntProp(prev, Prop_Data, "m_itemCount", 0);
							location[2] += 20;
							TeleportEntity(prev, location, angle, NULL_VECTOR);
							location[2] -= 20;
							RemoveEdict(prev);
							new index = CreateEntityByName("weapon_rifle_spawn");
							TeleportEntity(index, location, angle, NULL_VECTOR);
							DispatchKeyValue(index, "count", count);
							SetEntityModel(index, Rifle_model);
							DispatchSpawn(index);
							ActivateEntity(index);
							TierTwoEntID[i][1] = index;
							i++;
						}
					}
					prev = ent;
				}
				if (prev)
				{
					new abort;
					for (new j=0;j<10;j++)
						if (prev == TierTwoEntID[j][1])
							abort = 1;
					if (!abort)
					{
						new Float:location[3];
						new Float:angle[3];
						GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
						GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
						TierTwoLocations[i][1][0] = location;
						TierTwoLocations[i][1][1] = angle;
						SetEntProp(prev, Prop_Data, "m_itemCount", 0);
						location[2] += 20;
						TeleportEntity(prev, location, angle, NULL_VECTOR);
						location[2] -= 20;
						RemoveEdict(prev);
						new index = CreateEntityByName("weapon_rifle_spawn");
						TeleportEntity(index, location, angle, NULL_VECTOR);
						DispatchKeyValue(index, "count", count);
						SetEntityModel(index, Rifle_model);
						DispatchSpawn(index);
						ActivateEntity(index);
						TierTwoEntID[i][1] = index;
						if (IsSecond == 1)
							BuggedT2Removed = 1;
					}
				}
			}
		}
		return;
	}
	new String:PumpShotgun_model[128] = "models/w_models/weapons/w_shotgun.mdl";
	if (!IsModelPrecached(PumpShotgun_model))
	{
		PrecacheModel(PumpShotgun_model);
	}
	new String:SMG_model[128] = "models/w_models/weapons/w_smg_uzi.mdl";
	if (!IsModelPrecached(SMG_model))
	{
		PrecacheModel(SMG_model);
	}
	new ent = -1;
	new prev = 0;
	new String:count[2] = "5";
	new i = 0;
	if (IsSecond)
		i=5;
	while ((ent = FindEntityByClassname(ent, "weapon_autoshotgun_spawn")) != -1)
	{
		if (prev)
		{
			new Float:location[3];
			new Float:angle[3];
			GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
			GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
			TierTwoLocations[i][0][0] = location;
			TierTwoLocations[i][0][1] = angle;
			SetEntProp(prev, Prop_Data, "m_itemCount", 0);
			location[2] += 20;
			TeleportEntity(prev, location, angle, NULL_VECTOR);
			location[2] -= 20;
			RemoveEdict(prev);
			new index = CreateEntityByName("weapon_pumpshotgun_spawn");
			TeleportEntity(index, location, angle, NULL_VECTOR);
			DispatchKeyValue(index, "count", count);
			SetEntityModel(index, PumpShotgun_model);
			DispatchSpawn(index);
			ActivateEntity(index);
			i++;
		}
		prev = ent;
	}
	if (prev)
	{
		new Float:location[3];
		new Float:angle[3];
		GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
		GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
		TierTwoLocations[i][0][0] = location;
		TierTwoLocations[i][0][1] = angle;
		SetEntProp(prev, Prop_Data, "m_itemCount", 0);
		location[2] += 20;
		TeleportEntity(prev, location, angle, NULL_VECTOR);
		location[2] -= 20;
		RemoveEdict(prev);
		new index = CreateEntityByName("weapon_pumpshotgun_spawn");
		TeleportEntity(index, location, angle, NULL_VECTOR);
		DispatchKeyValue(index, "count", count);
		SetEntityModel(index, PumpShotgun_model);
		DispatchSpawn(index);
		ActivateEntity(index);
		if (IsSecond)
			BuggedT2Removed = 1;
	}
	ent= -1;
	prev = 0;
	i = 0;
	if (IsSecond)
		i=5;
	while ((ent = FindEntityByClassname(ent, "weapon_rifle_spawn")) != -1)
	{
		if (prev)
		{
			new Float:location[3];
			new Float:angle[3];
			GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
			GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
			TierTwoLocations[i][1][0] = location;
			TierTwoLocations[i][1][1] = angle;
			SetEntProp(prev, Prop_Data, "m_itemCount", 0);
			location[2] += 20;
			TeleportEntity(prev, location, angle, NULL_VECTOR);
			location[2] -= 20;
			RemoveEdict(prev);
			new index = CreateEntityByName("weapon_smg_spawn");
			TeleportEntity(index, location, angle, NULL_VECTOR);
			DispatchKeyValue(index, "count", count);
			SetEntityModel(index, SMG_model);
			DispatchSpawn(index);
			ActivateEntity(index);
			i++;
		}
		prev = ent;
	}
	if (prev)
	{
		new Float:location[3];
		new Float:angle[3];
		GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
		GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
		TierTwoLocations[i][1][0] = location;
		TierTwoLocations[i][1][1] = angle;
		SetEntProp(prev, Prop_Data, "m_itemCount", 0);
		location[2] += 20;
		TeleportEntity(prev, location, angle, NULL_VECTOR);
		location[2] -= 20;
		RemoveEdict(prev);
		new index = CreateEntityByName("weapon_smg_spawn");
		TeleportEntity(index, location, angle, NULL_VECTOR);
		DispatchKeyValue(index, "count", count);
		SetEntityModel(index, SMG_model);
		DispatchSpawn(index);
		ActivateEntity(index);
		if (IsSecond)
			BuggedT2Removed = 1;
	}
}
public DeleteTierTwo()
{
	new ent = -1;
	new prev = 0;
	while ((ent = FindEntityByClassname(ent, "weapon_autoshotgun_spawn")) != -1)
	{
		if (prev)
			RemoveEdict(prev);
		prev = ent;
	}
	if (prev)
		RemoveEdict(prev);
	prev = 0;
	while ((ent = FindEntityByClassname(ent, "weapon_rifle_spawn")) != -1)
	{
		if (prev)
			RemoveEdict(prev);
		prev = ent;
	}
	if (prev)
		RemoveEdict(prev);
	for (new i=0;i<10;i++)
		for (new j=0;j<2;j++)
			TierTwoEntID[i][j] = 0;
}
public PurgeTierTwo()
{
	new ent = -1;
	new prev = 0;
	while ((ent = FindEntityByClassname(ent, "weapon_autoshotgun_spawn")) != -1)
	{
		
		if (prev)
		{
			new clear = 1;
			for (new i=0;i<10;i++)
				if (TierTwoEntID[i][0] == prev)
					clear = 0;
			if (clear)
				RemoveEdict(prev);
		}
		prev = ent;
	}
	if (prev)
	{
		new clear = 1;
		for (new i=0;i<10;i++)
			if (TierTwoEntID[i][0] == prev)
				clear = 0;
		if (clear)
			RemoveEdict(prev);
	}
	prev = 0;
	while ((ent = FindEntityByClassname(ent, "weapon_rifle_spawn")) != -1)
	{
		if (prev)
		{
			new clear = 1;
			for (new i=0;i<10;i++)
				if (TierTwoEntID[i][1] == prev)
					clear = 0;
			if (clear)
				RemoveEdict(prev);
		}
		prev = ent;
	}
	if (prev)
	{
		new clear = 1;
		for (new i=0;i<10;i++)
			if (TierTwoEntID[i][1] == prev)
				clear = 0;
		if (clear)
			RemoveEdict(prev);
	}
}
public SpawnTierOne() //Spawns tier 1 in positions stored when tier 2 was removed
{
	decl String:map[128];
	GetCurrentMap(map, sizeof(map));
	new tierDisable = GetConVarInt(TDFenabled);
	if (IsFinale() && tierDisable)
	{
		switch(tierDisable)
		{
			case 2:
			{
				DeleteTierTwo();
				new String:AutoShotgun_model[128] = "models/w_models/weapons/w_autoshot_m4super.mdl";
				new String:count[2] = "1";
				if (!IsModelPrecached(AutoShotgun_model))
				{
					PrecacheModel(AutoShotgun_model);
				}
				new String:Rifle_model[128] = "models/w_models/weapons/w_rifle_m16a2.mdl";
				if (!IsModelPrecached(Rifle_model))
				{
					PrecacheModel(Rifle_model);
				}
				for (new i = 0; TierTwoLocations[i][0][0][0]; i++)
				{
					new index = CreateEntityByName("weapon_autoshotgun_spawn");
					TeleportEntity(index, TierTwoLocations[i][0][0], TierTwoLocations[i][0][1], NULL_VECTOR);
					DispatchKeyValue(index, "count", count);
					SetEntityModel(index, AutoShotgun_model);
					DispatchSpawn(index);
					ActivateEntity(index);
					TierTwoEntID[i][0] = index;
				}
				for (new i = 0; TierTwoLocations[i][1][0][0]; i++)
				{
					new index = CreateEntityByName("weapon_rifle_spawn");
					TeleportEntity(index, TierTwoLocations[i][1][0], TierTwoLocations[i][1][1], NULL_VECTOR);
					DispatchKeyValue(index, "count", count);
					SetEntityModel(index, Rifle_model);
					DispatchSpawn(index);
					ActivateEntity(index);
					TierTwoEntID[i][1] = index;
				}
				for (new i = 5; TierTwoLocations[i][0][0][0]; i++)
				{
					new index = CreateEntityByName("weapon_autoshotgun_spawn");
					TeleportEntity(index, TierTwoLocations[i][0][0], TierTwoLocations[i][0][1], NULL_VECTOR);
					DispatchKeyValue(index, "count", count);
					SetEntityModel(index, AutoShotgun_model);
					DispatchSpawn(index);
					ActivateEntity(index);
					TierTwoEntID[i][0] = index;
				}
				for (new i = 5; TierTwoLocations[i][1][0][0]; i++)
				{
					new index = CreateEntityByName("weapon_rifle_spawn");
					TeleportEntity(index, TierTwoLocations[i][1][0], TierTwoLocations[i][1][1], NULL_VECTOR);
					DispatchKeyValue(index, "count", count);
					SetEntityModel(index, Rifle_model);
					DispatchSpawn(index);
					ActivateEntity(index);
					TierTwoEntID[i][1] = index;
				}
			}
			case 3:
			{
				DeleteTierTwo();
				new String:AutoShotgun_model[128] = "models/w_models/weapons/w_autoshot_m4super.mdl";
				new String:count[2] = "1";
				if (!IsModelPrecached(AutoShotgun_model))
				{
					PrecacheModel(AutoShotgun_model);
				}
				new String:Rifle_model[128] = "models/w_models/weapons/w_rifle_m16a2.mdl";
				if (!IsModelPrecached(Rifle_model))
				{
					PrecacheModel(Rifle_model);
				}
				for (new i = 0; TierTwoLocations[i][0][0][0]; i++)
				{
					new index = CreateEntityByName("weapon_autoshotgun_spawn");
					TeleportEntity(index, TierTwoLocations[i][0][0], TierTwoLocations[i][0][1], NULL_VECTOR);
					DispatchKeyValue(index, "count", count);
					SetEntityModel(index, AutoShotgun_model);
					DispatchSpawn(index);
					ActivateEntity(index);
				}
				for (new i = 0; TierTwoLocations[i][1][0][0]; i++)
				{
					new index = CreateEntityByName("weapon_rifle_spawn");
					TeleportEntity(index, TierTwoLocations[i][1][0], TierTwoLocations[i][1][1], NULL_VECTOR);
					DispatchKeyValue(index, "count", count);
					SetEntityModel(index, Rifle_model);
					DispatchSpawn(index);
					ActivateEntity(index);
				}
				for (new i = 5; TierTwoLocations[i][0][0][0]; i++)
				{
					new index = CreateEntityByName("weapon_autoshotgun_spawn");
					TeleportEntity(index, TierTwoLocations[i][0][0], TierTwoLocations[i][0][1], NULL_VECTOR);
					DispatchKeyValue(index, "count", count);
					SetEntityModel(index, AutoShotgun_model);
					DispatchSpawn(index);
					ActivateEntity(index);
				}
				for (new i = 5; TierTwoLocations[i][1][0][0]; i++)
				{
					new index = CreateEntityByName("weapon_rifle_spawn");
					TeleportEntity(index, TierTwoLocations[i][1][0], TierTwoLocations[i][1][1], NULL_VECTOR);
					DispatchKeyValue(index, "count", count);
					SetEntityModel(index, Rifle_model);
					DispatchSpawn(index);
					ActivateEntity(index);
				}
			}
		}
		return;
	}
	new String:PumpShotgun_model[128] = "models/w_models/weapons/w_shotgun.mdl";
	new String:count[2] = "5";
	if (!IsModelPrecached(PumpShotgun_model))
	{
		PrecacheModel(PumpShotgun_model);
	}
	new String:SMG_model[128] = "models/w_models/weapons/w_smg_uzi.mdl";
	if (!IsModelPrecached(SMG_model))
	{
		PrecacheModel(SMG_model);
	}
	for (new i = 0; TierTwoLocations[i][0][0][0]; i++)
	{
		new index = CreateEntityByName("weapon_pumpshotgun_spawn");
		TeleportEntity(index, TierTwoLocations[i][0][0], TierTwoLocations[i][0][1], NULL_VECTOR);
		DispatchKeyValue(index, "count", count);
		SetEntityModel(index, PumpShotgun_model);
		DispatchSpawn(index);
		ActivateEntity(index);
	}
	for (new i = 0; TierTwoLocations[i][1][0][0]; i++)
	{
		new index = CreateEntityByName("weapon_smg_spawn");
		TeleportEntity(index, TierTwoLocations[i][1][0], TierTwoLocations[i][1][1], NULL_VECTOR);
		DispatchKeyValue(index, "count", count);
		SetEntityModel(index, SMG_model);
		DispatchSpawn(index);
		ActivateEntity(index);
	}
	for (new i = 5; TierTwoLocations[i][0][0][0]; i++)
	{
		new index = CreateEntityByName("weapon_pumpshotgun_spawn");
		TeleportEntity(index, TierTwoLocations[i][0][0], TierTwoLocations[i][0][1], NULL_VECTOR);
		DispatchKeyValue(index, "count", count);
		SetEntityModel(index, PumpShotgun_model);
		DispatchSpawn(index);
		ActivateEntity(index);
	}
	for (new i = 5; TierTwoLocations[i][1][0][0]; i++)
	{
		new index = CreateEntityByName("weapon_smg_spawn");
		TeleportEntity(index, TierTwoLocations[i][1][0], TierTwoLocations[i][1][1], NULL_VECTOR);
		DispatchKeyValue(index, "count", count);
		SetEntityModel(index, SMG_model);
		DispatchSpawn(index);
		ActivateEntity(index);
	}
}
public Action:Event_SpawnGive(Handle:event, const String:name[], bool:dontBroadcast)
{
	if (!GetConVarInt(CPenabled))
		return;
	new String:item[128];
	decl String:map[128];
	GetCurrentMap(map, sizeof(map))
	//GetEventString(event, "item", item, sizeof(item)); //Fucking valve and crash course, replaced with line below
	GetEdictClassname(GetEventInt(event, "spawner"), item, sizeof(item));
	if (1==2 && !TierTwoConverted2 && GetConVarInt(CPenabled) && GetConVarInt(TDenabled))
	{
		if (TierTwoSpawned2)
		{
			RemoveTierTwo(1);
			TierTwoSpawned2 = 0;
		}
		if (!TierTwoSpawned2)
		{
			SpawnTierOne();
		}
	}
	if (InPause)
		for (new i=0;i<5;i++)
			if (GetPlayerWeaponSlot(GetClientOfUserId(GetEventInt(event, "userid")), i) > 0)
			{
				decl String:sWeapon[36];
				GetEdictClassname(GetPlayerWeaponSlot(GetClientOfUserId(GetEventInt(event, "userid")), i), sWeapon, 32);
				StrCat(sWeapon, 36, "_spawn");
				if (StrEqual(sWeapon, item) && ((!StrEqual(sWeapon, "weapon_autoshotgun_spawn") && !StrEqual(sWeapon, "weapon_rifle_spawn")) || (!GetConVarInt(TDenabled) || GetConVarInt(TDFenabled) <= 1 || !IsFinale())))
				{
					RemovePlayerItem(GetClientOfUserId(GetEventInt(event, "userid")), GetPlayerWeaponSlot(GetClientOfUserId(GetEventInt(event, "userid")), i));
					SetEntProp(GetEventInt(event, "spawner"), Prop_Data, "m_itemCount", GetEntProp(GetEventInt(event, "spawner"), Prop_Data, "m_itemCount")+1);
					return;
				}
			}
	new tierDisable = GetConVarInt(TDFenabled);
	if (GetConVarInt(TDenabled) && IsFinale() && tierDisable)
	{
		if (!strcmp(item, "weapon_autoshotgun_spawn"))
		{
			if (!IsValidEntity(GetEventInt(event, "spawner")) || GetEntProp(GetEventInt(event, "spawner"), Prop_Data, "m_itemCount") < 1)
			{
				RemovePlayerItem(GetClientOfUserId(GetEventInt(event, "userid")), GetPlayerWeaponSlot(GetClientOfUserId(GetEventInt(event, "userid")), 0));
			}
			if (GetEntProp(GetEventInt(event, "spawner"), Prop_Data, "m_itemCount") >1)
				DropSlot(GetClientOfUserId(GetEventInt(event, "userid")), 0);
			switch(tierDisable)
			{
				case 2:
				{
					new ent = GetEventInt(event, "spawner");
					new String:PumpShotgun_model[128] = "models/w_models/weapons/w_shotgun.mdl";
					if (!IsModelPrecached(PumpShotgun_model))
					{
						PrecacheModel(PumpShotgun_model);
					}
					new Float:location[3];
					new Float:angle[3];
					GetEntPropVector(ent, Prop_Send, "m_vecOrigin", location);
					GetEntPropVector(ent, Prop_Send, "m_angRotation", angle);
					location[2] += 20;
					TeleportEntity(ent, location, angle, NULL_VECTOR);
					location[2] -= 20;
					RemoveEdict(ent);
					new index = CreateEntityByName("weapon_pumpshotgun_spawn");
					TeleportEntity(index, location, angle, NULL_VECTOR);
					DispatchKeyValue(index, "count", "5");
					//SetEntityModel(index, PumpShotgun_model);
					DispatchSpawn(index);
					ActivateEntity(index);
					RemoveTierTwo(2);
				}
				case 3:
				{
					new ent = GetEventInt(event, "spawner");
					//if(GetEntProp(ent, Prop_Data, "m_itemCount") <=1 )
					{
						new String:PumpShotgun_model[128] = "models/w_models/weapons/w_shotgun.mdl";
						if (!IsModelPrecached(PumpShotgun_model))
						{
							PrecacheModel(PumpShotgun_model);
						}
						new Float:location[3];
						new Float:angle[3];
						GetEntPropVector(ent, Prop_Send, "m_vecOrigin", location);
						GetEntPropVector(ent, Prop_Send, "m_angRotation", angle);
						location[2] += 20;
						TeleportEntity(ent, location, angle, NULL_VECTOR);
						location[2] -= 20;
						RemoveEdict(ent);
						new index = CreateEntityByName("weapon_pumpshotgun_spawn");
						TeleportEntity(index, location, angle, NULL_VECTOR);
						DispatchKeyValue(index, "count", "5");
						//SetEntityModel(ent, PumpShotgun_model);
						DispatchSpawn(index);
						ActivateEntity(index);
					}
				}
			}
			return;
		}
		else if (!strcmp(item, "weapon_rifle_spawn"))
		{
			if (!IsValidEntity(GetEventInt(event, "spawner")) || GetEntProp(GetEventInt(event, "spawner"), Prop_Data, "m_itemCount") < 1)
			{
				RemovePlayerItem(GetClientOfUserId(GetEventInt(event, "userid")), GetPlayerWeaponSlot(GetClientOfUserId(GetEventInt(event, "userid")), 0));
			}
			if (GetEntProp(GetEventInt(event, "spawner"), Prop_Data, "m_itemCount") >1)
				DropSlot(GetClientOfUserId(GetEventInt(event, "userid")), 0);
			switch(tierDisable)
			{
				case 2:
				{
					new ent = GetEventInt(event, "spawner");
					new String:SMG_model[128] = "models/w_models/weapons/w_smg_uzi.mdl";
					if (!IsModelPrecached(SMG_model))
					{
						PrecacheModel(SMG_model);
					}
					new Float:location[3];
					new Float:angle[3];
					GetEntPropVector(ent, Prop_Send, "m_vecOrigin", location);
					GetEntPropVector(ent, Prop_Send, "m_angRotation", angle);
					location[2] += 20;
					TeleportEntity(ent, location, angle, NULL_VECTOR);
					location[2] -= 20;
					RemoveEdict(ent);
					new index = CreateEntityByName("weapon_smg_spawn");
					TeleportEntity(index, location, angle, NULL_VECTOR);
					DispatchKeyValue(index, "count", "5");
					//SetEntityModel(index, SMG_model);
					DispatchSpawn(index);
					ActivateEntity(index);
					RemoveTierTwo(3);
				}
				case 3:
				{
					new ent = GetEventInt(event, "spawner");
					//if(GetEntProp(ent, Prop_Data, "m_itemCount") <=1 )
					{
						new String:SMG_model[128] = "models/w_models/weapons/w_smg_uzi.mdl";
						if (!IsModelPrecached(SMG_model))
						{
							PrecacheModel(SMG_model);
						}
						new Float:location[3];
						new Float:angle[3];
						GetEntPropVector(ent, Prop_Send, "m_vecOrigin", location);
						GetEntPropVector(ent, Prop_Send, "m_angRotation", angle);
						location[2] += 20;
						TeleportEntity(ent, location, angle, NULL_VECTOR);
						location[2] -= 20;
						RemoveEdict(ent);
						new index = CreateEntityByName("weapon_smg_spawn");
						TeleportEntity(index, location, angle, NULL_VECTOR);
						DispatchKeyValue(index, "count", "5");
						//SetEntityModel(index, SMG_model);
						DispatchSpawn(index);
						ActivateEntity(index);
					}
				}
			}
			return;
		}
	}
	if (!strcmp(item, "weapon_pain_pills_spawn") && GetConVarInt(FKenabled) && GetConVarInt(FKFenabled))
	{
		if (PillsPickedUp < 3)
		{
			if (GetConVarInt(DPenabled))
				for (new i=0;i<3;i++)
					if (PillSpawnGiven[i] == GetEventInt(event, "spawner"))
					{
						RemovePlayerItem(GetClientOfUserId(GetEventInt(event, "userid")), GetPlayerWeaponSlot(GetClientOfUserId(GetEventInt(event, "userid")), 4));
						return;
					}
			PillSpawnGiven[PillsPickedUp] = GetEventInt(event, "spawner");
			RemovePill(GetEventInt(event, "spawner"));  //remove that pill spawn from the list of converted pills
			PillsPickedUp++;
			return;
		}
		PillsPickedUp++;
		/*if (StrContains(map, "05_") != -1 && CheckPill(GetEventInt(event, "spawner"))) Since valve sugged out the spawn_give event, this method did not work.  Replaced with a method that determines how far pills are from the saferoom door.
		{
			if (PillsPickedUp == 4) //after the survivors pick up 4 converted pills, replaces the 4 remaining pill spawns to medkits
			{
				RemovePill(GetEventInt(event, "spawner"));
				new String:Medkit_model[128] = "w_models/weapons/w_eq_Medkit.mdl";
				if (!IsModelPrecached(Medkit_model))
				{
					PrecacheModel(Medkit_model);
				}
				new ent = -1;
				new prev = 0;
				new i = 0;
				while ((ent = FindEntityByClassname(ent, "weapon_pain_pills_spawn")) != -1 && i < 3)
				{
					new index = CreateEntityByName("weapon_first_aid_kit_spawn");
					if (index)
					{
						if (prev && CheckPill(prev))
						{
							new Float:location[3];
							new Float:angle[3];
							GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
							GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
							RemoveEdict(prev);
							SetEntityModel(index, Medkit_model);
							TeleportEntity(index, location, angle, NULL_VECTOR);
							DispatchSpawn(index);
							RemovePill(prev);
							i++;
						}
						prev = ent;
					}
				}
				new index = CreateEntityByName("weapon_first_aid_kit_spawn");
				if (index)
				{
					if (prev && CheckPill(prev))
					{
						new Float:location[3];
						new Float:angle[3];
						GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
						GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
						RemoveEdict(prev);
						SetEntityModel(index, Medkit_model);
						TeleportEntity(index, location, angle, NULL_VECTOR);
						DispatchSpawn(index);
						RemovePill(prev);
					}
				}
			}
		}*/
	}
}
public CheckPill(id) //returns whether an entity id is a set of converted pills
{
	for (new i = 0; i < 64; i++)
	{
		if (ConvertedPill[i] == id)
			return true;
	}
	return false;
}
public RemovePill(id) //removes an entity id from the list of converted pills
{
	for (new i = 0; i < 64; i++)
	{
		if (ConvertedPill[i] == id)
		{
			ConvertedPill[i] = 0;
			return;
		}
	}
	return;
}
public GetPill(id) //returns the index number of an entity id in the ConvertedPill array, 999 if none are found
{
	for (new i = 0; i < 64; i++)
	{
		if (ConvertedPill[i] == id)
			return i;
	}
	return 999;
}
public PauseGame() //Pause the game
{
	//doing director_stop on the server sets the below variables like so
	SetConVarInt(FindConVar("director_no_bosses"), 1);
	SetConVarInt(FindConVar("director_no_mobs"), 1);
	SetConVarInt(FindConVar("director_ready_duration"), 0);
	SetConVarInt(FindConVar("z_common_limit"), 0);
	SetConVarInt(FindConVar("z_mega_mob_size"), 1); //why not 0? only Valve knows
	
	//empty teams of survivors dont cycle the round
	SetConVarInt(FindConVar("sb_all_bot_team"), 1);
	//The above code is from Downtown1's ready up plugin
	
	SetConVarInt(FindConVar("nb_stop"), 1);
	SetConVarInt(FindConVar("sb_stop"), 1);
	SetConVarInt(FindConVar("tongue_range"), 0);
	SetConVarInt(FindConVar("z_vomit_duration"), 0);
	SetConVarInt(FindConVar("z_witch_anger_rate"), 0);
	SetConVarInt(FindConVar("z_witch_speed"), 0);
	SetConVarInt(FindConVar("z_witch_speed_inured"), 0); //why not injured? only Valve knows.
	for (new i=0;i<4;i++)
	{
		for (new j=0;j<5;j++)
			Format(SurvivorWeapons[i][j], 32, "");
		for (new j=0;j<7;j++)
			SurvivorAmmo[i][j] = 0;
	}
	InPause = 1;
	new tankFrustrated = 0;
	new ammoOffset = FindSendPropInfo("CTerrorPlayer", "m_iAmmo");
	for (new i=1;i<=MaxClients;i++)
	{
		if (IsClientInGame(i))
		{
			PauseClientIndex[i] = i;
			GetClientAuthString(i, InfectedAuthIDIndex[i], 33);
			SetEntityMoveType(i,MOVETYPE_NONE);
			if (GetClientTeam(i) == 2)
			{
				InfectedDeathTime[i] = -1.0;
				if (IsPlayerAlive(i))
				{
					SurvivorHealthBuffer[GetEntProp(i, Prop_Send, "m_survivorCharacter")] = GetEntPropFloat(i, Prop_Send, "m_healthBuffer")
					SurvivorHealthTime[GetEntProp(i, Prop_Send, "m_survivorCharacter")] = GetGameTime() - GetEntPropFloat(i, Prop_Send, "m_healthBufferTime");
					SetEntProp(i, Prop_Data, "m_fFlags", GetEntProp(i, Prop_Data, "m_fFlags") | FL_GODMODE);
					SurvivorAmmo[GetEntProp(i, Prop_Send, "m_survivorCharacter")][0] = GetEntData(i, ammoOffset+(2*4)); //HR
					SurvivorAmmo[GetEntProp(i, Prop_Send, "m_survivorCharacter")][1] = GetEntData(i, ammoOffset+(3*4)); //AR
					SurvivorAmmo[GetEntProp(i, Prop_Send, "m_survivorCharacter")][2] = GetEntData(i, ammoOffset+(5*4)); //SMG
					SurvivorAmmo[GetEntProp(i, Prop_Send, "m_survivorCharacter")][3] = GetEntData(i, ammoOffset+(6*4)); //SG
					SurvivorAmmo[GetEntProp(i, Prop_Send, "m_survivorCharacter")][4] = (GetEntProp(i, Prop_Send, "m_iAddonBits") & (FL_PISTOL|FL_PISTOL_PRIMARY)) > 0; //IsPistol?
					if (GetPlayerWeaponSlot(i, 0) > 0)
						SurvivorAmmo[GetEntProp(i, Prop_Send, "m_survivorCharacter")][5] = GetEntProp(GetPlayerWeaponSlot(i, 0), Prop_Send, "m_iClip1")
					else
						SurvivorAmmo[GetEntProp(i, Prop_Send, "m_survivorCharacter")][5] = 0;
					if (GetPlayerWeaponSlot(i, 1) > 0)
						SurvivorAmmo[GetEntProp(i, Prop_Send, "m_survivorCharacter")][6] = GetEntProp(GetPlayerWeaponSlot(i, 1), Prop_Send, "m_iClip1")
					else
						SurvivorAmmo[GetEntProp(i, Prop_Send, "m_survivorCharacter")][6] = 0;
					for (new j=4;j>=0;j--)
						if (GetPlayerWeaponSlot(i, j) > 0)
						{
							GetEdictClassname(GetPlayerWeaponSlot(i, j), SurvivorWeapons[GetEntProp(i, Prop_Send, "m_survivorCharacter")][j], 32);
							//RemoveEdict(GetPlayerWeaponSlot(i, j));
							RemovePlayerItem(i, GetPlayerWeaponSlot(i, j));
						}
					SetEntProp(i, Prop_Send, "m_iAddonBits", GetEntProp(i, Prop_Send, "m_iAddonBits") & (FL_PISTOL|FL_PISTOL_PRIMARY));
				}
				else
				{
					SurvivorHealthTime[GetEntProp(i, Prop_Send, "m_survivorCharacter")] = 0.0;
				}
			}
			else if (GetClientTeam(i) == 3)
			{
				if (GetEntProp(i, Prop_Send, "m_zombieClass") == 5 && IsPlayerAlive(i))
				{
					TankFrustration = GetEntProp(i, Prop_Send, "m_frustration");
					tankFrustrated = 1;
				}
				if (!IsPlayerAlive(i))
					InfectedDeathTime[i] = (GetConVarInt(FindConVar("z_ghost_delay_min"))+GetConVarInt(FindConVar("z_ghost_delay_min")))/2.0 - (GetGameTime() - GetEntPropFloat(i, Prop_Send, "m_flDeathTime") - 9.5);
				else
					InfectedDeathTime[i] = -1.0;
			}
		}
		else
		{
			PauseClientIndex[i] = -1;
			InfectedAuthIDIndex[i][0] = 0;
			InfectedDeathTime[i] = -1.0;
		}
	}
	if (!tankFrustrated)
		TankFrustration = -1;
	CreateTimer(0.5, ResetAllTemp, _, TIMER_REPEAT);
}
public ResumeGame()
{
	ResetConVar(FindConVar("director_no_bosses"));
	ResetConVar(FindConVar("director_no_mobs"));
	ResetConVar(FindConVar("director_ready_duration"));
	ResetConVar(FindConVar("z_common_limit"));
	ResetConVar(FindConVar("z_mega_mob_size"));
	//The above code is from Downtown1's ready up plugin
	ResetConVar(FindConVar("nb_stop"));
	ResetConVar(FindConVar("sb_stop"));
	ResetConVar(FindConVar("tongue_range"));
	ResetConVar(FindConVar("z_vomit_duration"));
	ResetConVar(FindConVar("z_witch_anger_rate"));
	ResetConVar(FindConVar("z_witch_speed"));
	ResetConVar(FindConVar("z_witch_speed_inured"));
	InPause = 0;
	SetCommandFlags("give", GetCommandFlags("give") & ~FCVAR_CHEAT);
	new ammoOffset = FindSendPropInfo("CTerrorPlayer", "m_iAmmo");
	for (new i=1;i<=MaxClients;i++)
	{
		if (!IsClientInGame(i))
			continue;
		if (IsPlayerAlive(i))
		{
			SetEntityMoveType(i,MOVETYPE_CUSTOM);
			if (GetClientTeam(i) == 2)
			{
				ResetTempHealth(i);
				SetEntProp(i, Prop_Data, "m_fFlags", GetEntProp(i, Prop_Data, "m_fFlags") & ~FL_GODMODE);
				for (new j=0;j<5;j++)
					if (SurvivorWeapons[GetEntProp(i, Prop_Send, "m_survivorCharacter")][j][0] != 0)
						FakeClientCommand(i, "give %s", SurvivorWeapons[GetEntProp(i, Prop_Send, "m_survivorCharacter")][j]);
				SetEntData(i, ammoOffset+(2*4), SurvivorAmmo[GetEntProp(i, Prop_Send, "m_survivorCharacter")][0]); //HR
				SetEntData(i, ammoOffset+(3*4), SurvivorAmmo[GetEntProp(i, Prop_Send, "m_survivorCharacter")][1]); //AR
				SetEntData(i, ammoOffset+(5*4), SurvivorAmmo[GetEntProp(i, Prop_Send, "m_survivorCharacter")][2]); //SMG
				SetEntData(i, ammoOffset+(6*4), SurvivorAmmo[GetEntProp(i, Prop_Send, "m_survivorCharacter")][3]); //SG
				if (SurvivorAmmo[GetEntProp(i, Prop_Send, "m_survivorCharacter")][4])
					FakeClientCommand(i, "give pistol");
				if (SurvivorWeapons[GetEntProp(i, Prop_Send, "m_survivorCharacter")][0][0])
					SetEntProp(GetPlayerWeaponSlot(i, 0), Prop_Send, "m_iClip1", SurvivorAmmo[GetEntProp(i, Prop_Send, "m_survivorCharacter")][5]);
				if (SurvivorWeapons[GetEntProp(i, Prop_Send, "m_survivorCharacter")][1][0])
					SetEntProp(GetPlayerWeaponSlot(i, 1), Prop_Send, "m_iClip1", SurvivorAmmo[GetEntProp(i, Prop_Send, "m_survivorCharacter")][6]);
			}
			else if (GetClientTeam(i) == 3)
			{
				if (GetEntProp(i, Prop_Send, "m_zombieClass") == 5 && TankFrustration != -1)
				{
					SetEntProp(i, Prop_Send, "m_frustration", TankFrustration)
					TankFrustration = -1;
				}
			}
		}
		decl String:TempAuth[33];
		GetClientAuthString(i, TempAuth, 33);
		for (new j=1;j<=MaxClients;j++)
			if (StrEqual(InfectedAuthIDIndex[j], TempAuth) && GetClientTeam(i) == 3 && InfectedDeathTime[j] != -1.0)
			{
				new Handle:pack;
				SetEntityMoveType(i,MOVETYPE_NONE);
				CreateDataTimer(1.0, FreezeSI, pack, TIMER_REPEAT);
				WritePackCell(pack, i);
				WritePackCell(pack, RoundToCeil(InfectedDeathTime[j]));
				WritePackCell(pack, RoundToCeil(GetGameTime()));
				InfectedDeathTime[j] = -1.0;
			}
		if (1==2 && PauseClientIndex[i] > 0 && IsClientInGame(PauseClientIndex[i]) && !IsFakeClient(PauseClientIndex[i]))
		{
			if (GetClientTeam(PauseClientIndex[i]) == 3 && InfectedDeathTime[i] != -1.0)
			{
				new Handle:pack;
				SetEntityMoveType(PauseClientIndex[i],MOVETYPE_NONE);
				CreateDataTimer(1.0, FreezeSI, pack, TIMER_REPEAT);
				WritePackCell(pack, PauseClientIndex[i]);
				WritePackCell(pack, RoundToCeil(InfectedDeathTime[i]));
				WritePackCell(pack, RoundToCeil(GetGameTime()));
				InfectedDeathTime[i] = -1.0;
			}
		}
	}
	SetCommandFlags("give", GetCommandFlags("give") | FCVAR_CHEAT);
}
public ResetTempHealth(client) //Restores a survivor's temp health to what it was when the game was paused.
{
	SetEntPropFloat(client, Prop_Send, "m_healthBufferTime", GetGameTime() - SurvivorHealthTime[GetEntProp(client, Prop_Send, "m_survivorCharacter")]);
}
public Action:Event_TankSpawn(Handle:event, const String:name[], bool:dontBroadcast)
{
	if (!GetConVarInt(CPenabled) || !GetConVarInt(TFenabled))
		return;
	if (InPause) //If somehow a tank spawned during a pause (possibly a tank passing as the game paused?) freeze it and set the frustration to 0.
	{
		SetEntityMoveType(GetEventInt(event, "tankid"),MOVETYPE_NONE);
		TankFrustration = 0;
	}
	if (IsFakeClient(GetEventInt(event, "tankid")) && !TankCulled) //If it's AI freeze it for 5 seconds
	{
		new Handle:pack;
		SetEntityMoveType(GetEventInt(event, "tankid"),MOVETYPE_NONE);
		SetEntProp(GetEventInt(event, "tankid"), Prop_Data, "m_fFlags", GetEntProp(GetEventInt(event, "tankid"), Prop_Data, "m_fFlags") | FL_GODMODE);
		AITankThaw = CreateDataTimer(5.0, ThawAI, pack, TIMER_FLAG_NO_MAPCHANGE);
		WritePackCell(pack, GetEventInt(event, "tankid"));
		return;
	}
	if (!IsFakeClient(GetEventInt(event, "tankid")) && !TankCulled) //If it's human, remove the freeze timer, and start a countdown to extinguish the tank
	{
		new Handle:pack;
		SetEntProp(GetEventInt(event, "tankid"), Prop_Data, "m_fFlags", GetEntProp(GetEventInt(event, "tankid"), Prop_Data, "m_fFlags") | FL_GODMODE);
		CreateDataTimer(3.0, Extinguish, pack);
		WritePackCell(pack, GetEventInt(event, "tankid"));
		SetEntityMoveType(GetEventInt(event, "tankid"),MOVETYPE_CUSTOM);
		if (AITankThaw != INVALID_HANDLE)
			CloseHandle(AITankThaw);
		return;
	}
	TankCulled = 0;  //If neither of the 2 functions were called, the tank was passed for this spawn, so reset that variable.
}
public Action:Extinguish(Handle:timer, Handle:pack) //extinguishes  a tank, and resets it's health
{
	ResetPack(pack);
	new client = ReadPackCell(pack);
	for (new i=1;i<=MaxClients;i++)
		if (IsClientInGame(i) && GetClientTeam(i) == 3 && GetEntProp(i, Prop_Send, "m_zombieClass") == 5)
			SetEntProp(i, Prop_Data, "m_fFlags", GetEntProp(i, Prop_Data, "m_fFlags") & ~FL_GODMODE); //Goes through every client and turns off godmode if they are in control of a tank.  Because of the importance of removing godmode on a tank, I don't trust the client ID passed.
	if (!IsClientConnected(client) || !IsClientInGame(client))
		return;
	if (GetEntProp(client, Prop_Data, "m_fFlags") & FL_ONFIRE && GetConVarInt(TCenabled))
		CreateTimer(1.0, HintText, client, TIMER_REPEAT);
	ExtinguishEntity(client);
}
public bool:IsSafeToPause()  //Loosely based off of AtomicStryker's survivorai triggerfix, and a couple of the map co-ords came from his plugin
{
	decl String:map[128];
	GetCurrentMap(map, sizeof(map));
	if (StrContains(map, "hospital02_subway") != 1)
	{
		decl Float:pos1[3];
		pos1[0] = 7316.1;
		pos1[1] = 3291.9;
		pos1[2] = 78.0;
		if (!CheckDistance(pos1, 200.0))
			return false;
	}
	if (StrContains(map, "hospital03_sewers") != 1)
	{
		decl Float:pos1[3];
		pos1[0] = 12656.0;
		pos1[1] = 7328.6;
		pos1[2] = 123.0;
		if (!CheckDistance(pos1, 200.0))
			return false;
	}
	if (StrContains(map, "hospital04_interior") != 1)
	{
		decl Float:pos1[3];
		pos1[0] = 13488.7;
		pos1[1] = 15093.5;
		pos1[2] = 479.8;
		if (!CheckDistance(pos1, 200.0))
			return false
	}
	if (StrContains(map, "farm02_traintunnel") != 1)
	{
		decl Float:pos1[3];
		pos1[0] = -8605.0;
		pos1[1] = -7530.0;
		pos1[2] = -21.0;
		if (!CheckDistance(pos1, 200.0))
			return false;
	}
	if (StrContains(map, "farm03_bridge") != 1)
	{
		decl Float:pos1[3];
		pos1[0] = 8077.0;
		pos1[1] = -13569.1;
		pos1[2] = 74.0;
		if (!CheckDistance(pos1, 200.0))
			return false;
	}
	if (StrContains(map, "smalltown02_drainage") != 1)
	{
		decl Float:pos1[3];
		pos1[0] = -8684.3;
		pos1[1] = -7836.4;
		pos1[2] = -392.4;
		if (!CheckDistance(pos1, 200.0))
			return false;
	}
	if (StrContains(map, "smalltown03_ranchhouse") != 1)
	{
		decl Float:pos1[3];
		pos1[0] = -2565.3;
		pos1[1] = 69.0;
		pos1[2] = 222.0;
		if (!CheckDistance(pos1, 200.0))
			return false;
	}
	if (StrContains(map, "smalltown04_mainstreet") != 1)
	{
		decl Float:pos1[3];
		pos1[0] = 1098.1;
		pos1[1] = -4153.6;
		pos1[2] = -1.9;
		if (!CheckDistance(pos1, 200.0))
			return false;
	}
	if (StrContains(map, "airport02_offices") != 1)
	{
		decl Float:pos1[3];
		pos1[0] = 6059.5;
		pos1[1] = 3828.9;
		pos1[2] = 711.9;
		if (!CheckDistance(pos1, 200.0))
			return false;
	}
	if (StrContains(map, "airport03_garage") != 1)
	{
		decl Float:pos1[3];
		pos1[0] = -5376.8;
		pos1[1] = -991.1;
		pos1[2] = 78.5;
		if (!CheckDistance(pos1, 1500.0))
			return false;
	}
	if (StrContains(map, "airport04_terminal") != 1)
	{
		decl Float:pos1[3];
		pos1[0] = -420.1;
		pos1[1] = 4291.8;
		pos1[2] = 78.0;
		if (!CheckDistance(pos1, 200.0))
			return false;
	}
	if (StrContains(map, "garage01_alleys") != 1)
	{
		decl Float:pos1[3];
		pos1[0] = -1322.3;
		pos1[1] = -6480.6;
		pos1[2] = 57.9;
		if (!CheckDistance(pos1, 200.0))
			return false;
	}
	return true;
}
public bool:CheckDistance(Float:origin[3], Float:DistTolerance)  //Loosely based off of AtomicStryker's function in survivorai triggerfix
{
	for (new i=1;i<=MaxClients;i++)
		if (IsClientInGame(i) && IsClientConnected(i) && IsPlayerAlive(i) && GetClientTeam(i) == 2)
		{
			decl Float:clientpos[3];
			GetEntPropVector(i, Prop_Send, "m_vecOrigin", clientpos);
			if (GetVectorDistance(origin, clientpos) <= DistTolerance)
				return false;
		}
	return true;
}
/*public Action:Event_PlayerSpawn(Handle:event, const String:name[], bool:dontBroadcast) //Used to remove the tier 2 spawns that appear after the  event
{
	if (&& !TierTwoConverted && GetConVarInt(CPenabled) && GetConVarInt(TDenabled))
	{
		if (TierTwoSpawned)
		{
			RemoveTierTwo(0);
			TierTwoSpawned = 0;
		}
		if (!TierTwoSpawned)
		{
			SpawnTierOne();
		}
	}
}*/ //Commented out since it was replaced by a timer on round_start
public Action:ThawAI(Handle:timer, Handle:pack) //Thaws an AI tank, it will only fire after 5 seconds which means it was not passed to a player.  Either because of no player infected, or being passed to AI
{
	ResetPack(pack);
	new TankID=ReadPackCell(pack);
	for (new i=1;i<=MaxClients;i++)
		if (IsClientInGame(i) && GetClientTeam(i) == 3 && GetEntProp(i, Prop_Send, "m_zombieClass") == 5)
			SetEntProp(i, Prop_Data, "m_fFlags", GetEntProp(i, Prop_Data, "m_fFlags") & ~FL_GODMODE);
	SetEntityMoveType(TankID, MOVETYPE_CUSTOM);
}
public Action:UnPauseCountDown(Handle:timer, Handle:pack)
{
	ResetPack(pack);
	new timeslooped = RoundToCeil(GetGameTime())-ReadPackCell(pack);
	if (timeslooped >= 5)
	{
		PrintHintTextToAll("Game is LIVE");
		unpausing = 0;
		ResumeGame();
		return Plugin_Stop;
	}
	PrintHintTextToAll("Unpausing in %d...", 5-timeslooped);
	if (timeslooped <= 1 || !unpausing)
		unpausing = 1;
	return Plugin_Continue;
}

public Action:Event_Culled(Handle:event, const String:name[], bool:dontBroadcast)
{
	TankCulled = 1;
}

public ClearKits()
{
	decl String:map[128];
	GetCurrentMap(map, 128);
	if (GetConVarInt(FKenabled) && StrContains(map, "hospital03_sewers") != -1) //Changes all medkits on the map into pills, and stores the converted pill's entity ID to be able to convert them into medkits later if needed
	{
		new String:Painpill_model[128] = "w_models/weapons/w_eq_painpills.mdl";
		if (!IsModelPrecached(Painpill_model))
		{
			PrecacheModel(Painpill_model);
		}
		new ent = -1;
		new prev = 0;
		new i = 0;
		while ((ent = FindEntityByClassname(ent, "weapon_first_aid_kit_spawn")) != -1)
		{
			new index = CreateEntityByName("weapon_pain_pills_spawn");
			if (index)
			{
				if (prev)
				{
					new Float:location[3];
					new Float:angle[3];
					GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
					GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
					RemoveEdict(prev);
					SetEntityModel(index, Painpill_model);
					TeleportEntity(index, location, angle, NULL_VECTOR);
					DispatchSpawn(index);
					ConvertedPill[i] = index;
					i++;
				}
				prev = ent;
			}
		}
		new index = CreateEntityByName("weapon_pain_pills_spawn");
		if (index)
		{
			if (prev)
			{
				new Float:location[3];
				new Float:angle[3];
				GetEntPropVector(prev, Prop_Send, "m_vecOrigin", location);
				GetEntPropVector(prev, Prop_Send, "m_angRotation", angle);
				RemoveEdict(prev);
				SetEntityModel(index, Painpill_model);
				TeleportEntity(index, location, angle, NULL_VECTOR);
				DispatchSpawn(index);
				ConvertedPill[i] = index;
			}
		}
	}
}
public IsFinale()
{
	decl String:map[128];
	GetCurrentMap(map, 128);
	if (StrContains(map, "05_") != -1 || StrContains(map, "_garage02_") != -1)
		return true;
	return false;
}